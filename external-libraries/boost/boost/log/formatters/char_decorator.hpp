/*
 *          Copyright Andrey Semashev 2007 - 2010.
 * Distributed under the Boost Software License, Version 1.0.
 *    (See accompanying file LICENSE_1_0.txt or copy at
 *          http://www.boost.org/LICENSE_1_0.txt)
 */
/*!
 * \file   char_decorator.hpp
 * \author Andrey Semashev
 * \date   07.06.2009
 *
 * The header contains implementation of a character decorator.
 */

#if (defined(_MSC_VER) && _MSC_VER > 1000)
#pragma once
#endif // _MSC_VER > 1000

#ifndef BOOST_LOG_FORMATTERS_CHAR_DECORATOR_HPP_INCLUDED_
#define BOOST_LOG_FORMATTERS_CHAR_DECORATOR_HPP_INCLUDED_

#include <vector>
#include <utility>
#include <boost/assert.hpp>
#include <boost/io/ios_state.hpp>
#include <boost/range/begin.hpp>
#include <boost/range/end.hpp>
#include <boost/range/iterator.hpp>
#include <boost/algorithm/string/replace.hpp>
#include <boost/log/detail/prologue.hpp>
#include <boost/log/detail/cleanup_scope_guard.hpp>
#include <boost/log/detail/attachable_sstream_buf.hpp>
#include <boost/log/formatters/basic_formatters.hpp>

namespace boost {

namespace BOOST_LOG_NAMESPACE {

namespace formatters {

/*!
 * Character decorator class. This formatter allows to modify strings generated by other
 * formatters on character level. The most obvious application of decorators is replacing
 * a certain set of characters with decorated equivalents to satisfy requirements of
 * text-based sinks.
 *
 * The \c fmt_char_decorator class aggregates the formatter being decorated, and a set
 * of string pairs that are used as decorations. All decorations are applied sequentially.
 * The \c fmt_char_decorator class is a formatter itself, so it can be used to construct
 * more complex formatters, including nesting decorators.
 */
template< typename FormatterT >
class fmt_char_decorator :
    public basic_formatter< typename FormatterT::char_type, fmt_char_decorator< FormatterT > >
{
private:
    //! Base type
    typedef basic_formatter< typename FormatterT::char_type, fmt_char_decorator< FormatterT > > base_type;

public:
    //! Character type
    typedef typename base_type::char_type char_type;
    //! Decorated formatter type
    typedef FormatterT formatter_type;
    //! String type
    typedef typename base_type::string_type string_type;
    //! Stream type
    typedef typename base_type::ostream_type ostream_type;
    //! Log record type
    typedef typename base_type::record_type record_type;

private:
    //! Stream buffer type
    typedef boost::log::aux::basic_ostringstreambuf< char_type > streambuf_type;
    //! Streambuffer saver type
    typedef io::basic_ios_rdbuf_saver<
        typename ostream_type::char_type,
        typename ostream_type::traits_type
    > rdbuf_saver;
    //! List of the decorations to apply
    typedef std::vector< std::pair< string_type, string_type > > decorations_list;

private:
    //! Decorated formatter
    formatter_type m_Formatter;
    //! Formatted string
    mutable string_type m_Storage;
    //! Stream buffer to fill the storage
    mutable streambuf_type m_StreamBuf;
    //! The list of decorations
    decorations_list m_Decorations;

public:
    /*!
     * Initializing constructor. Creates decorator of the \a fmt formatter with the specified \a decorations.
     */
    template< typename RangeT >
    fmt_char_decorator(formatter_type const& fmt, RangeT const& decorations) :
        m_Formatter(fmt),
        m_StreamBuf(m_Storage),
        m_Decorations(begin(decorations), end(decorations))
    {
    }
    /*!
     * Initializing constructor. Creates decorator of the \a fmt formatter with decorations specified
     * in form of two same-sized string sequences. Each <tt>i</tt>'th decoration will be
     * <tt>from[i]</tt> -> <tt>to[i]</tt>.
     */
    template< typename RangeT1, typename RangeT2 >
    fmt_char_decorator(formatter_type const& fmt, RangeT1 const& from, RangeT2 const& to) :
        m_Formatter(fmt),
        m_StreamBuf(m_Storage)
    {
        typedef typename decorations_list::value_type value_type;
        typedef typename range_iterator< RangeT1 >::type iterator1;
        typedef typename range_iterator< RangeT2 >::type iterator2;
        iterator1 it1 = begin(from), end1 = end(from);
        iterator2 it2 = begin(to), end2 = end(to);
        for (; it1 != end1 && it2 != end2; ++it1, ++it2)
        {
            m_Decorations.push_back(value_type(*it1, *it2));
        }

        // Both sequences should be of the same size
        BOOST_ASSERT(it1 == end1);
        BOOST_ASSERT(it2 == end2);
    }
    /*!
     * Copy constructor
     */
    fmt_char_decorator(fmt_char_decorator const& that) :
        m_Formatter(that.m_Formatter),
        m_StreamBuf(m_Storage),
        m_Decorations(that.m_Decorations)
    {
    }

    /*!
     * Formatting operator. Invokes the decorated formatter, then sequentially applies all
     * decorations to the output. The resulting string is the output of the decorator.
     *
     * \param strm A reference to the stream, where the final text of the logging record is composed
     * \param record A logging record
     */
    void operator() (ostream_type& strm, record_type const& record) const
    {
        boost::log::aux::cleanup_guard< string_type > cleanup1(m_Storage);
        boost::log::aux::cleanup_guard< streambuf_type > cleanup2(m_StreamBuf);

        {
            // Perform formatting
            rdbuf_saver cleanup3(strm, &m_StreamBuf);
            m_Formatter(strm, record);
            strm.flush();
        }

        // Apply decorations
        typedef typename decorations_list::const_iterator dec_iterator;
        for (dec_iterator it = m_Decorations.begin(), end = m_Decorations.end(); it != end; ++it)
        {
            algorithm::replace_all(m_Storage, it->first, it->second);
        }

        // Put the final string into the stream
        strm.write(m_Storage.data(), static_cast< std::streamsize >(m_Storage.size()));
    }

private:
    //! Assignment prohibited
    fmt_char_decorator& operator= (fmt_char_decorator const& that);
};

namespace aux {

    template< typename RangeT >
    class fmt_char_decorator_gen1
    {
        RangeT const& m_Decorations;

    public:
        explicit fmt_char_decorator_gen1(RangeT const& decorations) : m_Decorations(decorations)
        {
        }

        template< typename FormatterT >
        fmt_char_decorator< FormatterT > operator[] (FormatterT const& fmt) const
        {
            return fmt_char_decorator< FormatterT >(fmt, m_Decorations);
        }
    };

    template< typename RangeT1, typename RangeT2 >
    class fmt_char_decorator_gen2
    {
        RangeT1 const& m_From;
        RangeT2 const& m_To;

    public:
        fmt_char_decorator_gen2(RangeT1 const& from, RangeT2 const& to) : m_From(from), m_To(to)
        {
        }

        template< typename FormatterT >
        fmt_char_decorator< FormatterT > operator[] (FormatterT const& fmt) const
        {
            return fmt_char_decorator< FormatterT >(fmt, m_From, m_To);
        }
    };

} // namespace aux

#ifndef BOOST_LOG_DOXYGEN_PASS

//! Generator function
template< typename RangeT >
inline aux::fmt_char_decorator_gen1< RangeT > char_dec(RangeT const& decorations)
{
    return aux::fmt_char_decorator_gen1< RangeT >(decorations);
}
//! Generator function
template< typename RangeT1, typename RangeT2 >
inline aux::fmt_char_decorator_gen2< RangeT1, RangeT2 > char_dec(RangeT1 const& from, RangeT2 const& to)
{
    return aux::fmt_char_decorator_gen2< RangeT1, RangeT2 >(from, to);
}

#else // BOOST_LOG_DOXYGEN_PASS

/*!
 * The function returns a decorator generator object. The generator provides <tt>operator[]</tt> that can be used
 * to construct the actual decorator.
 *
 * \param decorations A sequence of string pairs that will be used as decorations. Every <tt>decorations[i].first</tt>
 *                    substring occurrence in the output will be replaced with <tt>decorations[i].second</tt>.
 */
template< typename RangeT >
implementation_defined char_dec(RangeT const& decorations);

/*!
 * The function returns a decorator generator object. The generator provides <tt>operator[]</tt> that can be used
 * to construct the actual decorator.
 *
 * \param from A sequence of strings that will be sought in the output.
 * \param to A sequence of strings that will be used as replacements.
 *
 * \note The \a from and \a to sequences mush be of the same size. Every <tt>from[i]</tt>
 *       substring occurrence in the output will be replaced with <tt>to[i]</tt>.
 */
template< typename RangeT1, typename RangeT2 >
implementation_defined char_dec(RangeT1 const& from, RangeT2 const& to);

#endif // BOOST_LOG_DOXYGEN_PASS

} // namespace formatters

} // namespace log

} // namespace boost

#endif // BOOST_LOG_FORMATTERS_CHAR_DECORATOR_HPP_INCLUDED_
